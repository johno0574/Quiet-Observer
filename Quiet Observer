import React, { useState, useEffect, useCallback } from 'react';

import { Button } from '@/components/ui/button';

import { Input } from '@/components/ui/input';

import { Textarea } from '@/components/ui/textarea';

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';

import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';

import { AlertCircle, File, FilePlus, FileSearch, Settings, Terminal, Tree, Zap } from 'lucide-react'; // Import relevant icons

import { cn } from "@/lib/utils"

interface LogData {

&nbsp;   id: string;

&nbsp;   diameter: number;

&nbsp;   length: number;

&nbsp;   species: string;

&nbsp;   defects: string\[\];

&nbsp;   grade: string;

}

interface CuttingPattern {

&nbsp;   cuts: { length: number; grade: string; quantity: number }\[\];

&nbsp;   totalYield: number;

}

const TimberYieldOptimizerApp = () => {

&nbsp;   const \[logInput, setLogInput\] = useState&lt;string&gt;('');

&nbsp;   const \[logData, setLogData\] = useState&lt;LogData\[\]&gt;(\[\]);

&nbsp;   const \[cuttingPatterns, setCuttingPatterns\] = useState&lt;CuttingPattern\[\]&gt;(\[\]);

&nbsp;   const \[error, setError\] = useState&lt;string | null&gt;(null);

&nbsp;   const \[loading, setLoading\] = useState&lt;boolean&gt;(false);

&nbsp;   const \[systemPrompt, setSystemPrompt\] = useState&lt;string&gt;(\`

&nbsp;       You are a timber yield optimization expert.  Given log data, determine the best cutting pattern

&nbsp;       to maximize the yield of high-grade timber.

&nbsp;       Log data is provided as comma-separated values, one log per line. The fields are:

&nbsp;       "Log ID","Diameter (cm)","Length (m)","Species","Defects (comma-separated)","Grade".

&nbsp;       Example Log Data:

&nbsp;       "L1",30,2.5,Pine,"Knot,Crack",A

&nbsp;       "L2",40,3.0,Oak,"",B

&nbsp;       "L3",25,2.0,Pine,"Split",C

&nbsp;       Provide at least 3 different cutting patterns, each with varying cut lengths and grades.

&nbsp;       Consider the following preferred timber lengths (in meters) : 2.4, 3.0, 3.6, 4.2, 4.8, 5.4

&nbsp;       Prioritize the highest grades (A, B, C, D) and maximize total yield.

&nbsp;       Clearly indicate the total yield (in cubic meters) for each pattern.

&nbsp;       Format your response as Markdown.  Use clear headings.

&nbsp;       Example Output:

&nbsp;       ## Cutting Pattern 1

&nbsp;       | Cut Length (m) | Grade | Quantity |

&nbsp;       |---|---|---|

&nbsp;       | 4.8 | A | 1 |

&nbsp;       | 3.0 | B | 2 |

&nbsp;       Total Yield: 2.5 m3

&nbsp;       ## Cutting Pattern 2

&nbsp;       | Cut Length (m) | Grade | Quantity |

&nbsp;       |---|---|---|

&nbsp;       | 3.6 | A | 2 |

&nbsp;       | 2.4 | B | 1 |

&nbsp;       Total Yield: 2.2 m3

&nbsp;       ## Cutting Pattern 3

&nbsp;       | Cut Length (m) | Grade | Quantity |

&nbsp;       |---|---|---|

&nbsp;       | 3.0 | B | 3 |

&nbsp;       Total Yield: 2.0 m3

&nbsp;   \`);

&nbsp;   const \[apiKey, setApiKey\] = useState&lt;string | null&gt;(null);

&nbsp;   // Load API key from localStorage

&nbsp;   useEffect(() => {

&nbsp;       const savedApiKey = localStorage.getItem('openai_api_key');

&nbsp;       if (savedApiKey) {

&nbsp;           setApiKey(savedApiKey);

&nbsp;       }

&nbsp;   }, \[\]);

&nbsp;   // Function to parse log input

&nbsp;   const parseLogInput = useCallback((input: string) => {

&nbsp;       const parsedLogs: LogData\[\] = \[\];

&nbsp;       const lines = input.trim().split('\\n');

&nbsp;       lines.forEach((line, index) => {

&nbsp;           const values = line.split(',');

&nbsp;           if (values.length !== 6) {

&nbsp;               setError(\`Invalid log data format on line ${index + 1}.  Expected 6 values.\`);

&nbsp;               return;

&nbsp;           }

&nbsp;           const id = values\[0\].trim();

&nbsp;           const diameter = parseFloat(values\[1\].trim());

&nbsp;           const length = parseFloat(values\[2\].trim());

&nbsp;           const species = values\[3\].trim();

&nbsp;           const defects = values\[4\].split(',').map(d => d.trim()).filter(d => d !== '');

&nbsp;           const grade = values\[5\].trim();

&nbsp;           if (isNaN(diameter) || isNaN(length) || length <= 0 || diameter <= 0) {

&nbsp;               setError(\`Invalid numeric data on line ${index + 1}. Diameter and Length must be numbers > 0.\`);

&nbsp;               return;

&nbsp;           }

&nbsp;           if (!\['A', 'B', 'C', 'D'\].includes(grade)) {

&nbsp;               setError(\`Invalid grade on line ${index + 1}. Grade must be A, B, C, or D.\`);

&nbsp;               return;

&nbsp;           }

&nbsp;           parsedLogs.push({ id, diameter, length, species, defects, grade });

&nbsp;       });

&nbsp;       return parsedLogs;

&nbsp;   }, \[\]);

&nbsp;   // Function to call the OpenAI API (simulated)

&nbsp;   const getCuttingPatterns = useCallback(async (logs: LogData\[\], systemPrompt: string, apiKey: string | null) => {

&nbsp;       if (!apiKey) {

&nbsp;           throw new Error("OpenAI API key is required.");

&nbsp;       }

&nbsp;       setLoading(true);

&nbsp;       setError(null);

&nbsp;       setCuttingPatterns(\[\]);

&nbsp;       // Simulate API call and response.  Replace this with actual API call.

&nbsp;       try {

&nbsp;           // 1. Convert log data to a string format suitable for the prompt

&nbsp;           let logDataString = \`"Log ID","Diameter (cm)","Length (m)","Species","Defects (comma-separated)","Grade"\\n\`;

&nbsp;           logs.forEach(log => {

&nbsp;               logDataString += \`"${log.id}",${log.diameter},${log.length},${log.species},"${log.defects.join(',')}",${log.grade}\\n\`;

&nbsp;           });

&nbsp;           const fullPrompt = \`${systemPrompt}\\n\\nLog Data:\\n${logDataString}\`;

&nbsp;           // Simulate a delay (replace with actual API call)

&nbsp;           await new Promise(resolve => setTimeout(resolve, 2000));

&nbsp;           // 2. Mock OpenAI response (replace with actual parsed response)

&nbsp;           const mockResponse = \`

\## Cutting Pattern 1

| Cut Length (m) | Grade | Quantity |

|---|---|---|

| 4.8 | A | 1 |

| 3.0 | B | 2 |

Total Yield: 2.5 m3

\## Cutting Pattern 2

| Cut Length (m) | Grade | Quantity |

|---|---|---|

| 3.6 | A | 2 |

| 2.4 | B | 1 |

Total Yield: 2.2 m3

\## Cutting Pattern 3

| Cut Length (m) | Grade | Quantity |

|---|---|---|

| 3.0 | B | 3 |

Total Yield: 2.0 m3

&nbsp;           \`;

&nbsp;           // 3. Parse the mock response (replace with actual parsing)

&nbsp;           const parsedPatterns: CuttingPattern\[\] = \[\];

&nbsp;           const patternRegex = /## Cutting Pattern (\\d+)\\n\\| Cut Length \\(m\\) \\| Grade \\| Quantity \\|\\n\\|---|---|---\\|\\n(\[\\s\\S\]+?)\\nTotal Yield: (\\d+\\.\\d+) m3/g;

&nbsp;           let match;

&nbsp;           while ((match = patternRegex.exec(mockResponse)) !== null) {

&nbsp;               const patternNumber = parseInt(match\[1\], 10);

&nbsp;               const cutLines = match\[2\].trim().split('\\n');

&nbsp;               const cuts = cutLines.map(line => {

&nbsp;                   const values = line.split('|').map(v => v.trim()).filter(v => v !== '');

&nbsp;                   return {

&nbsp;                       length: parseFloat(values\[0\]),

&nbsp;                       grade: values\[1\],

&nbsp;                       quantity: parseInt(values\[2\], 10),

&nbsp;                   };

&nbsp;               });

&nbsp;               const totalYield = parseFloat(match\[3\]);

&nbsp;               parsedPatterns.push({ cuts, totalYield });

&nbsp;           }

&nbsp;           if (parsedPatterns.length === 0) {

&nbsp;               throw new Error("No cutting patterns found in the response.");

&nbsp;           }

&nbsp;           setCuttingPatterns(parsedPatterns);

&nbsp;       } catch (err: any) {

&nbsp;           setError(err.message);

&nbsp;       } finally {

&nbsp;           setLoading(false);

&nbsp;       }

&nbsp;   }, \[\]);

&nbsp;   // Function to handle form submission

&nbsp;   const handleOptimize = async () => {

&nbsp;       const parsedLogs = parseLogInput(logInput);

&nbsp;       if (parsedLogs.length > 0) {

&nbsp;           setLogData(parsedLogs);

&nbsp;           try {

&nbsp;               await getCuttingPatterns(parsedLogs, systemPrompt, apiKey);

&nbsp;           } catch (error: any) {

&nbsp;               setError(error.message);

&nbsp;           }

&nbsp;       }

&nbsp;   };

&nbsp;   const handleClear = () => {

&nbsp;       setLogInput('');

&nbsp;       setLogData(\[\]);

&nbsp;       setCuttingPatterns(\[\]);

&nbsp;       setError(null);

&nbsp;   };

&nbsp;   const handleSaveApiKey = () => {

&nbsp;       if (apiKey) {

&nbsp;           localStorage.setItem('openai_api_key', apiKey);

&nbsp;           alert('API Key Saved!  Reload the app for changes to take effect.');

&nbsp;       } else {

&nbsp;           localStorage.removeItem('openai_api_key');

&nbsp;           alert('API Key Removed!  Reload the app for changes to take effect.');

&nbsp;       }

&nbsp;   };

&nbsp;   return (

&nbsp;       &lt;div className="min-h-screen bg-gray-100 dark:bg-gray-900 p-4"&gt;

&nbsp;           &lt;div className="container mx-auto"&gt;

&nbsp;               &lt;h1 className="text-3xl font-bold text-gray-800 dark:text-white mb-6 flex items-center gap-2"&gt;

&nbsp;                   &lt;Tree className="w-6 h-6" /&gt; Timber Yield Optimizer

&nbsp;               &lt;/h1&gt;

&nbsp;               &lt;div className="grid grid-cols-1 md:grid-cols-2 gap-6"&gt;

&nbsp;                   {/\* Input Section \*/}

&nbsp;                   &lt;Card className="shadow-lg"&gt;

&nbsp;                       &lt;CardHeader&gt;

&nbsp;                           &lt;CardTitle className="flex items-center gap-2"&gt;

&nbsp;                               &lt;FilePlus className="w-5 h-5" /&gt; Log Data Input

&nbsp;                           &lt;/CardTitle&gt;

&nbsp;                           &lt;CardDescription&gt;Enter log data in CSV format.&lt;/CardDescription&gt;

&nbsp;                       &lt;/CardHeader&gt;

&nbsp;                       &lt;CardContent&gt;

&nbsp;                           <Textarea

&nbsp;                               placeholder='"Log ID","Diameter (cm)","Length (m)","Species","Defects (comma-separated)","Grade"

"L1",30,2.5,Pine,"Knot,Crack",A

"L2",40,3.0,Oak,"",B

"L3",25,2.0,Pine,"Split",C'

&nbsp;                               value={logInput}

&nbsp;                               onChange={(e) => setLogInput(e.target.value)}

&nbsp;                               className="mb-4 min-h-\[200px\]"

&nbsp;                               disabled={loading}

&nbsp;                           />

&nbsp;                           &lt;div className="flex gap-4"&gt;

&nbsp;                               <Button

&nbsp;                                   onClick={handleOptimize}

&nbsp;                                   disabled={loading}

&nbsp;                                   className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded flex items-center gap-2"

&nbsp;                               >

&nbsp;                                   {loading ? (

&nbsp;                                       <>

&nbsp;                                           &lt;Zap className="animate-spin w-4 h-4" /&gt; Optimizing...

&nbsp;                                       &lt;/&gt;

&nbsp;                                   ) : (

&nbsp;                                       <>

&nbsp;                                           &lt;Zap className="w-4 h-4" /&gt; Optimize

&nbsp;                                       &lt;/&gt;

&nbsp;                                   )}

&nbsp;                               &lt;/Button&gt;

&nbsp;                               <Button

&nbsp;                                   onClick={handleClear}

&nbsp;                                   variant="outline"

&nbsp;                                   className="bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-white font-bold py-2 px-4 rounded flex items-center gap-2"

&nbsp;                               >

&nbsp;                                   &lt;File className="w-4 h-4" /&gt; Clear

&nbsp;                               &lt;/Button&gt;

&nbsp;                           &lt;/div&gt;

&nbsp;                       &lt;/CardContent&gt;

&nbsp;                   &lt;/Card&gt;

&nbsp;                   {/\* Output Section \*/}

&nbsp;                   &lt;Card className="shadow-lg"&gt;

&nbsp;                       &lt;CardHeader&gt;

&nbsp;                           &lt;CardTitle className="flex items-center gap-2"&gt;

&nbsp;                               &lt;FileSearch className="w-5 h-5" /&gt; Optimization Results

&nbsp;                           &lt;/CardTitle&gt;

&nbsp;                           &lt;CardDescription&gt;Suggested cutting patterns for maximum yield.&lt;/CardDescription&gt;

&nbsp;                       &lt;/CardHeader&gt;

&nbsp;                       &lt;CardContent&gt;

&nbsp;                           {loading && &lt;p className="text-gray-600 dark:text-gray-400"&gt;Loading...&lt;/p&gt;}

&nbsp;                           {error && (

&nbsp;                               &lt;Alert variant="destructive"&gt;

&nbsp;                                   &lt;AlertCircle className="h-4 w-4" /&gt;

&nbsp;                                   &lt;AlertTitle&gt;Error&lt;/AlertTitle&gt;

&nbsp;                                   &lt;AlertDescription&gt;{error}&lt;/AlertDescription&gt;

&nbsp;                               &lt;/Alert&gt;

&nbsp;                           )}

&nbsp;                           {!loading && !error && cuttingPatterns.length > 0 && (

&nbsp;                               &lt;div className="space-y-4"&gt;

&nbsp;                                   {cuttingPatterns.map((pattern, index) => (

&nbsp;                                       &lt;div key={index} className="border rounded-md p-4 bg-gray-50 dark:bg-gray-800 dark:border-gray-700"&gt;

&nbsp;                                           &lt;h3 className="text-lg font-semibold text-gray-800 dark:text-white mb-2"&gt;Cutting Pattern {index + 1}&lt;/h3&gt;

&nbsp;                                           &lt;div className="overflow-x-auto"&gt;

&nbsp;                                               &lt;table className="min-w-full"&gt;

&nbsp;                                                   &lt;thead className="bg-gray-100 dark:bg-gray-700"&gt;

&nbsp;                                                       &lt;tr&gt;

&nbsp;                                                           &lt;th className="px-4 py-2 text-left text-gray-600 dark:text-gray-300"&gt;Cut Length (m)&lt;/th&gt;

&nbsp;                                                           &lt;th className="px-4 py-2 text-left text-gray-600 dark:text-gray-300"&gt;Grade&lt;/th&gt;

&nbsp;                                                           &lt;th className="px-4 py-2 text-left text-gray-600 dark:text-gray-300"&gt;Quantity&lt;/th&gt;

&nbsp;                                                       &lt;/tr&gt;

&nbsp;                                                   &lt;/thead&gt;

&nbsp;                                                   &lt;tbody&gt;

&nbsp;                                                       {pattern.cuts.map((cut, cutIndex) => (

&nbsp;                                                           &lt;tr key={cutIndex} className={cutIndex % 2 === 0 ? 'bg-white dark:bg-gray-900' : 'bg-gray-50 dark:bg-gray-800'}&gt;

&nbsp;                                                               &lt;td className="px-4 py-2 text-gray-700 dark:text-gray-200"&gt;{cut.length}&lt;/td&gt;

&nbsp;                                                               &lt;td className="px-4 py-2 text-gray-700 dark:text-gray-200"&gt;{cut.grade}&lt;/td&gt;

&nbsp;                                                               &lt;td className="px-4 py-2 text-gray-700 dark:text-gray-200"&gt;{cut.quantity}&lt;/td&gt;

&nbsp;                                                           &lt;/tr&gt;

&nbsp;                                                       ))}

&nbsp;                                                   &lt;/tbody&gt;

&nbsp;                                               &lt;/table&gt;

&nbsp;                                           &lt;/div&gt;

&nbsp;                                           &lt;p className="mt-2 text-md font-medium text-gray-800 dark:text-white"&gt;Total Yield: {pattern.totalYield} m3&lt;/p&gt;

&nbsp;                                       &lt;/div&gt;

&nbsp;                                   ))}

&nbsp;                               &lt;/div&gt;

&nbsp;                           )}

&nbsp;                           {!loading && !error && logData.length > 0 && cuttingPatterns.length === 0 && (

&nbsp;                               &lt;p className="text-gray-600 dark:text-gray-400"&gt;No optimal cutting patterns found.&lt;/p&gt;

&nbsp;                           )}

&nbsp;                           {!loading && !error && logData.length === 0 && (

&nbsp;                               &lt;p className="text-gray-600 dark:text-gray-400"&gt;Enter log data to see cutting patterns.&lt;/p&gt;

&nbsp;                           )}

&nbsp;                       &lt;/CardContent&gt;

&nbsp;                   &lt;/Card&gt;

&nbsp;               &lt;/div&gt;

&nbsp;               &lt;Card className="shadow-lg mt-6"&gt;

&nbsp;                   &lt;CardHeader&gt;

&nbsp;                       &lt;CardTitle className="flex items-center gap-2"&gt;

&nbsp;                           &lt;Settings className="w-5 h-5" /&gt; Settings

&nbsp;                       &lt;/CardTitle&gt;

&nbsp;                       &lt;CardDescription&gt;Configure the application.&lt;/CardDescription&gt;

&nbsp;                   &lt;/CardHeader&gt;

&nbsp;                   &lt;CardContent className="space-y-4"&gt;

&nbsp;                       &lt;div className="space-y-2"&gt;

&nbsp;                           &lt;label htmlFor="openai-api-key" className="text-sm font-medium block text-gray-700 dark:text-gray-200"&gt;

&nbsp;                               OpenAI API Key

&nbsp;                           &lt;/label&gt;

&nbsp;                           <Input

&nbsp;                               id="openai-api-key"

&nbsp;                               type="password"

&nbsp;                               value={apiKey || ''}

&nbsp;                               onChange={(e) => setApiKey(e.target.value)}

&nbsp;                               placeholder="Enter your OpenAI API key"

&nbsp;                               className="w-full"

&nbsp;                           />

&nbsp;                           &lt;p className="text-xs text-gray-500 dark:text-gray-400"&gt;

&nbsp;                               This key is used to communicate with the OpenAI API.

&nbsp;                           &lt;/p&gt;

&nbsp;                           <Button

&nbsp;                               onClick={handleSaveApiKey}

&nbsp;                               className="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded"

&nbsp;                           >

&nbsp;                               Save API Key

&nbsp;                           &lt;/Button&gt;

&nbsp;                       &lt;/div&gt;

&nbsp;                       &lt;div className="space-y-2"&gt;

&nbsp;                           &lt;label htmlFor="system-prompt" className="text-sm font-medium block text-gray-700 dark:text-gray-200 flex items-center gap-1"&gt;

&nbsp;                               &lt;Terminal className="w-4 h-4" /&gt; System Prompt

&nbsp;                           &lt;/label&gt;

&nbsp;                           <Textarea

&nbsp;                               id="system-prompt"

&nbsp;                               value={systemPrompt}

&nbsp;                               onChange={(e) => setSystemPrompt(e.target.value)}

&nbsp;                               className="min-h-\[200px\] w-full"

&nbsp;                               placeholder="Enter the system prompt for the OpenAI API."

&nbsp;                           />

&nbsp;                           &lt;p className="text-xs text-gray-500 dark:text-gray-400"&gt;

&nbsp;                               This prompt instructs the AI on how to analyze the log data and provide cutting patterns.

&nbsp;                           &lt;/p&gt;

&nbsp;                       &lt;/div&gt;

&nbsp;                   &lt;/CardContent&gt;

&nbsp;               &lt;/Card&gt;

&nbsp;           &lt;/div&gt;

&nbsp;       &lt;/div&gt;

&nbsp;   );

};

export default TimberYieldOptimizerApp;

echo "# Quiet-Observer" >> README.md

git init

git add README.md

git commit -m "first commit"

git branch -M main

git remote add origin <https://github.com/johno0574/Quiet-Observer.git>

git push -u origin main

/\* General Body & Typography \*/

body {

font-family: 'Roboto', sans-serif;

margin: 0;

padding: 0;

background-color: #121212; /\* Dark background \*/

color: #E0E0E0; /\* Light text \*/

line-height: 1.6;

}

h1, h2, h3 {

font-family: 'Orbitron', sans-serif;

color: #00FFC0; /\* Neon green/aqua highlight \*/

text-align: center;

margin-bottom: 20px;

}

h1 { font-size: 2.8em; }

h2 { font-size: 2.2em; }

h3 { font-size: 1.8em; }

p {

text-align: center;

max-width: 800px;

margin: 0 auto 15px auto;

}

a {

color: #00FFC0;

text-decoration: none;

transition: color 0.3s ease;

}

a:hover {

color: #00E0A0;

}

.container {

max-width: 1200px;

margin: 0 auto;

padding: 20px;

}

.section-padded {

padding: 80px 20px;

}

.section-alt {

background-color: #1A1A1A; /\* Slightly lighter dark for contrast \*/

padding: 80px 20px;

}

/\* Header & Navigation \*/

header {

background-color: #000000;

padding: 15px 0;

border-bottom: 1px solid #333;

position: sticky;

top: 0;

z-index: 1000;

}

nav {

display: flex;

justify-content: space-between;

align-items: center;

max-width: 1200px;

margin: 0 auto;

padding: 0 20px;

}

nav .logo {

display: flex;

align-items: center;

}

nav .logo img {

height: 40px;

margin-right: 10px;

}

nav .logo h1 {

font-size: 1.8em;

margin: 0;

color: #00FFC0;

}

nav ul {

list-style: none;

margin: 0;

padding: 0;

display: flex;

}

nav ul li {

margin-left: 30px;

}

nav ul li a {

font-family: 'Orbitron', sans-serif;

color: #E0E0E0;

font-weight: 700;

text-transform: uppercase;

transition: color 0.3s ease;

}

nav ul li a:hover {

color: #00FFC0;

}

/\* Hero Section \*/

.hero-section {

background-image: url('images/hero-bg.jpg'); /\* Replace with your background image \*/

background-size: cover;

background-position: center;

color: #fff;

text-align: center;

padding: 150px 20px;

display: flex;

flex-direction: column;

justify-content: center;

align-items: center;

position: relative;

overflow: hidden; /\* Prevent background content bleed \*/

}

.hero-section::before {

content: '';

position: absolute;

top: 0;

left: 0;

right: 0;

bottom: 0;

background: rgba(0, 0, 0, 0.7); /\* Dark overlay for readability \*/

z-index: 0; /\* Behind content \*/

}

.hero-content {

position: relative; /\* Brings content above the overlay \*/

z-index: 1;

}

.hero-logo-large {

width: 150px; /\* Adjust size as needed \*/

height: auto;

margin-bottom: 20px;

animation: pulse 2s infinite ease-in-out; /\* Simple animation \*/

}

@keyframes pulse {

0% { transform: scale(1); }

50% { transform: scale(1.05); }

100% { transform: scale(1); }

}

.hero-content h2 {

font-size: 3.5em;

margin-bottom: 10px;

color: #00FFC0;

text-shadow: 0 0 15px rgba(0,255,192,0.8); /\* Neon glow effect \*/

}

.hero-content p {

font-size: 1.2em;

margin-bottom: 40px;

max-width: 700px;

}

.hero-buttons {

display: flex;

justify-content: center;

gap: 20px;

flex-wrap: wrap; /\* Allow buttons to wrap on smaller screens \*/

}

.btn {

display: inline-block;

padding: 15px 30px;

border-radius: 5px;

font-weight: bold;

text-transform: uppercase;

transition: all 0.3s ease;

text-align: center;

}

.btn.primary {

background-color: #00FFC0;

color: #121212;

border: 2px solid #00FFC0;

}

.btn.primary:hover {

background-color: transparent;

color: #00FFC0;

box-shadow: 0 0 15px rgba(0,255,192,0.8);

}

.btn.secondary {

background-color: transparent;

color: #00FFC0;

border: 2px solid #00FFC0;

}

.btn.secondary:hover {

background-color: #00FFC0;

color: #121212;

box-shadow: 0 0 15px rgba(0,255,192,0.8);

}

/\* Tokenomics Section \*/

.tokenomics-grid {

display: grid;

grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /\* Responsive grid \*/

gap: 30px;

margin-top: 40px;

}

.tokenomics-item {

background-color: #222;

padding: 30px;

border-radius: 10px;

text-align: center;

box-shadow: 0 0 15px rgba(0,255,192,0.1);

}

.tokenomics-item h3 {

font-size: 1.5em;

color: #00FFC0;

margin-top: 0;

}

.tokenomics-item p {

font-size: 1.1em;

color: #E0E0E0;

margin: 0;

}

.disclaimer {

margin-top: 40px;

font-size: 0.9em;

color: #888;

}

/\* Tokenomics contract address clickable \*/

# contract-address {

cursor: pointer;

text-decoration: underline;

}

# contract-address:hover {

color: #00E0A0;

}

/\* Roadmap Section \*/

.roadmap-phases {

display: flex;

flex-wrap: wrap; /\* Allow phases to wrap on smaller screens \*/

justify-content: center;

gap: 40px;

margin-top: 40px;

}

.phase {

background-color: #222;

padding: 30px;

border-radius: 10px;

width: 30%; /\* Adjust for 3 columns on desktop \*/

min-width: 300px; /\* Minimum width before stacking \*/

box-shadow: 0 0 15px rgba(0,255,192,0.1);

}

.phase h3 {

color: #00FFC0;

margin-top: 0;

text-align: left; /\* Align roadmap phase titles left \*/

}

.phase ul {

list-style: none;

padding: 0;

margin-top: 20px;

}

.phase ul li {

padding-left: 25px;

position: relative;

margin-bottom: 10px;

color: #E0E0E0;

text-align: left; /\* Ensure list items are left-aligned \*/

}

.phase ul li::before {

content: '•'; /\* Bullet point \*/

color: #00FFC0;

font-size: 1.2em;

position: absolute;

left: 0;

top: -2px;

}

/\* Charity Section \*/

.charity-details {

max-width: 800px;

margin: 40px auto;

background-color: #222;

padding: 40px;

border-radius: 10px;

box-shadow: 0 0 15px rgba(0,255,192,0.1);

}

.charity-details p {

text-align: left;

margin-bottom: 15px;

}

.charity-details ul {

list-style: none;

padding: 0;

margin-bottom: 20px;

max-width: none; /\* Override section p styling \*/

}

.charity-details ul li {

padding-left: 25px;

position: relative;

margin-bottom: 10px;

color: #E0E0E0;

text-align: left;

}

.charity-details ul li::before {

content: '✓'; /\* Checkmark \*/

color: #00FFC0;

font-size: 1.2em;

position: absolute;

left: 0;

top: -2px;

}

.charity-details .btn {

margin-top: 20px;

display: block; /\* Make button full width in this context \*/

width: fit-content; /\* Adjust width to content \*/

margin-left: auto;

margin-right: auto;

}

/\* Community Section \*/

.social-links {

display: flex;

justify-content: center;

gap: 25px;

margin-top: 40px;

flex-wrap: wrap; /\* Allow social buttons to wrap \*/

}

.social-btn {

display: inline-flex; /\* Use flexbox for icon alignment if you add icons \*/

align-items: center;

padding: 12px 25px;

border-radius: 5px;

font-weight: bold;

text-transform: uppercase;

transition: all 0.3s ease;

border: 2px solid;

}

.social-btn.twitter {

background-color: #1DA1F2;

border-color: #1DA1F2;

color: #fff;

}

.social-btn.twitter:hover {

background-color: transparent;

color: #1DA1F2;

}

.social-btn.telegram {

background-color: #2CA5E0;

border-color: #2CA5E0;

color: #fff;

}

.social-btn.telegram:hover {

background-color: transparent;

color: #2CA5E0;

}

.social-btn.discord {

background-color: #5865F2;

border-color: #5865F2;

color: #fff;

}

.social-btn.discord:hover {

background-color: transparent;

color: #5865F2;

}

/\* Footer \*/

footer {

background-color: #000;

color: #888;

text-align: center;

padding: 30px 20px;

font-size: 0.9em;

border-top: 1px solid #333;

}

footer p {

margin: 5px auto;

max-width: 100%; /\* Override main p styling \*/

}

footer a {

color: #00FFC0;

}

.disclaimer-footer {

margin-top: 15px;

font-size: 0.8em;

color: #666;

}

/\* Responsive Design \*/

@media (max-width: 768px) {

nav ul {

flex-direction: column;

width: 100%;

margin-top: 15px;

align-items: center;

display: none; /\* Hidden by default for mobile, will be toggled by JS \*/

}

nav ul.active {

display: flex;

}

nav ul li {

margin: 10px 0;

}

nav {

flex-direction: column;

}

.hero-content h2 {

font-size: 2.5em;

}

.hero-content p {

font-size: 1em;

}

.tokenomics-grid, .roadmap-phases {

grid-template-columns: 1fr; /\* Stack columns on small screens \*/

width: 100%;

}

.phase {

width: 100%;

}

.social-links {

flex-direction: column;

}

.social-btn {

width: 80%; /\* Make social buttons wider on small screens \*/

max-width: 300px;

}

}

document.addEventListener('DOMContentLoaded', () => {

// Smooth scrolling for navigation links

document.querySelectorAll('nav a\[href^="#"\]').forEach(anchor => {

anchor.addEventListener('click', function (e) {

e.preventDefault();

document.querySelector(this.getAttribute('href')).scrollIntoView({

behavior: 'smooth'

});

});

});

// Copy contract address on click

const contractAddressElement = document.getElementById('contract-address');

if (contractAddressElement) {

contractAddressElement.addEventListener('click', () => {

const address = contractAddressElement.textContent.trim();

navigator.clipboard.writeText(address).then(() => {

const originalText = contractAddressElement.textContent;

contractAddressElement.textContent = 'Copied!';

setTimeout(() => {

contractAddressElement.textContent = originalText;

}, 1500); // Change back after 1.5 seconds

}).catch(err => {

console.error('Failed to copy address: ', err);

alert('Could not copy address. Please copy it manually: ' + address);

});

});

}

// Basic mobile navigation toggle (if you add a hamburger menu)

// You'd need to add a hamburger icon in your HTML for this to work.

// Example HTML: &lt;button class="menu-toggle"&gt;☰&lt;/button&gt; inside &lt;nav&gt;

const menuToggle = document.querySelector('.menu-toggle');

const navUl = document.querySelector('nav ul');

if (menuToggle && navUl) {

menuToggle.addEventListener('click', () => {

navUl.classList.toggle('active');

});

}

});
